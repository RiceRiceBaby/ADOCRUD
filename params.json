{"name":"ADOCRUD","tagline":"Lightweight ORM thats built on top of ADO.NET and is partly an extension of Dapper. Handles automatic insert, update, and removal of objects without having to write any sql statements for Create, Update, and Remove functionality. The query part of this ORM is an extension of Dapper which means you still need to write sql statements to retrieve data, but that data will automatically be mapped to your C# objects. Most of this application was written primarily using reflection.  This ORM comes with an object class generator tool. This tool allows you to connect to a Sql Server database, grabs all the tables, and generates C# objects as .cs files and outputs them to the folder you specify.","body":"# ADOCRUD\r\nLightweight ORM thats built on top of ADO.NET and is partly an extension of Dapper. Handles automatic insert, update, and removal of objects without having to write any sql statements for Create, Update, and Remove functionality. The query part of this ORM is an extension of Dapper which means you still need to write sql statements to retrieve data, but that data will automatically be mapped to your C# objects. Most of this application was written primarily using reflection.<br /><br />\r\nThis ORM comes with an object class generator tool. This tool allows you to connect to a Sql Server database, grabs all the tables, and generates C# objects as .cs files and outputs them to the folder you specify.\r\n\r\n## ADOCRUDContext (ORM)\r\n\r\nModel Example:<br />\r\n\r\n```cs\r\nusing ADOCRUD.Attributes;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\n\r\nnamespace ADOCRUDExamples.Models\r\n{\r\n    [Table(\"Product\", \"dbo\")]\r\n    public class Product\r\n    {\r\n        [PrimaryKey]\r\n        [Member]\r\n        public int Id { get; set; }\r\n\r\n        [Member]\r\n        public int CategoryId { get; set; }\r\n\r\n        [Member]\r\n        public string Name { get; set; }\r\n\r\n        [Member]\r\n        public decimal Price { get; set; }\r\n\r\n        [Member]\r\n        public string Description { get; set; }\r\n\r\n    }\r\n}\r\n```\r\n\r\nFor your objects to work with the ADOCRUD ORM, attributes are required. Table attribute specifies which database table the object maps to. The first argument in the table attribute is the table name. The 2nd argument specifies the schema the table belongs to. For example, the attribute [Table(\"Product\", \"dbo\")] looks for the table \"dbo.Product\". Member attribute specifies that the property corresponds to a column in the table. Properties that do not have this member attribute will be ignored and excluded from any database manipulation (insert, update, remove). PrimaryKey attribute specifies that the property corresponds with the identity/primary key column of the table.\r\n\r\nInsert Example: <br />\r\n\r\n```cs\r\npublic void AddProduct(Product p)\r\n{\r\n  using (ADOCRUDContext context = new ADOCRUDContext(connectionString))\r\n  {\r\n    context.Insert<Product>(p);\r\n    context.Commit();\r\n  }\r\n}\r\n```\r\nUsing statement opens up a connection to the database specified in the connection string and also starts up a transaction. The insert does not finalize unless you call the commit method of the context. ADOCRUDContext closes the connection and disposes the transaction on Dispose() which means the connection gets closed and the transaction gets disposed at the end of the using statement.\r\n\r\nUpdate Example: <br />\r\n\r\n```cs\r\npublic void UpdateProduct(Product p)\r\n{\r\n  using (ADOCRUDContext context = new ADOCRUDContext(connectionString))\r\n  {\r\n      context.Update<Product>(p);\r\n      context.Commit();\r\n  }\r\n}\r\n```\r\nUpdate behaves the same way as the insert. It starts up a transaction and opens a connection in the beginning of the using statement. Completes the transaction on the commit method. Closes the connection and disposes the transaction on Dispose() which is the final bracket of the using statement.\r\n\r\n```cs\r\npublic void Remove(Product p)\r\n{\r\n  using (ADOCRUDContext context = new ADOCRUDContext(connectionString))\r\n  {\r\n      context.Remove<Product>(p);\r\n      context.Commit();\r\n  }\r\n}\r\n```\r\nRemove behaves the same way as the previous 2 methods.\r\n\r\nQuery Example:\r\n\r\n```cs\r\npublic Product GetProductById(int productId)\r\n{\r\n  Product p = null;\r\n\r\n  using (ADOCRUDContext context = new ADOCRUDContext(connectionString))\r\n  {\r\n    p = context.QueryItems<Product>(\"select * from dbo.Product where Id = @id\", new { id = productId }).FirstOrDefault();\r\n  }\r\n  \r\n  return p;\r\n}\r\n```\r\nQueryItems is a wrapper around Dapper's \"query\" method. QueryItems executes the select statement you pass in, grabs the results of the query and automatically maps it the C# object(s) and returns that/those object. The QueryItems function by default returns a list of objects, but you can limit it to a single object by using the \"First()\" or \"FirstOrDefault()\" method. Notice that to keep the query parameterized, you pass the parameters in the 2nd argument as a single object. To pass in extra parameters, you just add in comma separated values (i.e new { Id = productId, name = \"Basketball\", price = 11.99 })<br />\r\n\r\n###<b>Limitations:</b><br />\r\n\\#1. Does not support nested transactions, but does support nested connections. In other words, you can create a using context within another using context, but if both contexts call their respective commmit method and the outer context fails and the inner context succeeds, the changes in that inner context will still be applied to the database while the outer commit will roll back whatever it tried to do.<br />\r\n\r\n\\#2. Spelling and letter casing between C# properties and their corresponding sql columns the properties maps to must be exactly the same.<br />\r\n<i>Example that works: SQL Column: ProductId, C# Property: public int ProductId { get; set; }<br />\r\nExample that does not work: SQL Column: product_id, C# Property: public int ProductId { get; set; }</i>\r\n\r\n##ADOCRUD Object Class Generator\r\n\r\nThe object class generator tool provides a graphical user interface that is pretty straight forward to use. This generator scans all the tables in the Sql Server database entered and generates C# objects/classes for each of those tables. <br />\r\n<b>Sql Server Datasource:</b> <i>Name of the server</i><br />\r\n<b>Database:</b> <i>Name of the database</i><br />\r\n<b>User Id:</b> <i>Sql server user id that has access to the database</i><br />\r\n<b>Password:</b> <i>Sql server password of the user</i><br />\r\n<b>C# Namespace:</b> <i>Namespace the C# class should be under</i><br />\r\n<b>Output Path:</b> <i>File path where all the C# classes should be generated</i><br />\r\n<b>Generate Objects:</b> <i>Clicking this button generates all the C# objects in the file path entered.</i>\r\n\r\n##License\r\nLicense is under Apache. This means that this software is free for personal or commercial use.\r\n\r\n## Issues\r\nIf you find an issue with this software, please click <a href=\"https://github.com/RiceRiceBaby/ADOCRUD/issues\">here</a> to submit a ticket.\r\n\r\n##Author\r\nName: Daniel Li<br />\r\nMy Twitter Handle: https://twitter.com/DanielDavidLi<br />\r\nLinkedIn Profile: https://www.linkedin.com/in/danieldli?trk=hp-identity-name<br />\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}